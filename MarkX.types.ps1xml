<!-- Generated with EZOut 2.0.6: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>MarkX</Name>
    <Members>
      <MemberSet>
        <Name>PSStandardMembers</Name>
        <Members>
          <PropertySet>
            <Name>DefaultDisplayPropertySet</Name>
            <ReferencedProperties>
              <Name>Markdown</Name>
              <Name>XML</Name>
            </ReferencedProperties>
          </PropertySet>
        </Members>
      </MemberSet>
      <AliasProperty>
        <Name>DB</Name>
        <ReferencedMemberName>DataSet</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Link</Name>
        <ReferencedMemberName>Links</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Tables</Name>
        <ReferencedMemberName>Table</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Sync</Name>
        <Script>
                        $Markdown = $this.'#Markdown'

if (-not $Markdown) { return }

$this | 
    Add-Member NoteProperty '#HTML' (
        $Markdown | 
            ConvertFrom-Markdown | 
            Select-Object -ExpandProperty Html
    ) -Force

$this | 
    Add-Member NoteProperty '#XML' (
        "&lt;xhtml&gt;$($this.'#HTML')&lt;/xhtml&gt;" -as [xml]
    ) -Force

if (-not $this.'#XML') { return }

$tables = $this.'#XML' | Select-Xml //table
if (-not $tables) { return }
filter innerText {
    $in = $_
    if ($in -is [string]) { "$in" }
    elseif ($in.innerText) { "$($in.innerText)" }
    elseif ($in.'#text') { "$($in.'#text')" }
}

function bestType {
    $allIn = @($input) + @(if ($args) { $args})
    switch ($true) {        
        { $allIn -as [float[]] } {
            [float]; break
        }
        { $allIn -as [double[]] } {
            [double]; break
        }
        { $allIn -as [long[]] } {
            [long]; break
        }
        { $allIn -as [ulong[]] } {
            [uint32]; break
        }
        { $allIn -as [decimal[]] } {
            [decimal]; break
        }                        
        { $allIn -as [timespan[]] } {
            [timespan]; break
        }                
        { $allIn -as [DateTime[]] } {
            [DateTime]; break
        }
        default {
            [string]
        }
    }            
}

$markdownData = [Data.DataSet]::new('MarkX')
$tableNumber = 0
foreach ($table in $tables) {
    $tableNumber++
    $markdownDataTable  = $markdownData.Tables.Add("MarkdownTable$tableNumber")
    
    [string[]]$PropertyNames = @( $table.Node.thead.tr.th | innerText )

    # We want to upcast our datatable as much as possible
    # so we need to collect the rows first
    $TableDictionary = [Ordered]@{}
    $propertyIndex = 0
    foreach ($property in $propertyNames) {        
        $TableDictionary[$property] = @(
            foreach ($row in $table.Node.tbody.tr) {
                @($row.td)[$propertyIndex] | innerText
            }
        )
        $propertyIndex++
    }    

    # Now that we have all of the data collected,
    $markdownDataTable.Columns.AddRange(@(        
        foreach ($property in $propertyNames) {
            $propertyIndex = 0
            $bestType = $TableDictionary[$property] | bestType
            [Data.DataColumn]::new($property, $bestType, '', 'Attribute')
        }
        [Data.DataColumn]::new('tr', [xml.xmlelement], '', 'Hidden')
    ))
        
    foreach ($row in $table.Node.tbody.tr) {
        $propertyValues = @(            
            $row.td | innerText
            $row
        )
        $null = $markdownDataTable.Rows.Add($propertyValues)
    }

    $previous = $table.Node.PreviousSibling
    if ($previous.LocalName -eq 'blockquote') {
        $markdownDataTable.ExtendedProperties.Add("description", $previous.InnerText)
        $previous = $previous.PreviousSibling
    }
    if ($previous.LocalName -match 'h[1-6]') {
        $markdownDataTable.TableName = $previous.InnerText
    }
}

$this | Add-Member NoteProperty '#DataSet' $markdownData -Force

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ToString</Name>
        <Script>
                        if (-not $this.XML.XHTML) { return '' }
return ("$($this.XML.XHTML.InnerXML)" + [Environment]::NewLine)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ToTable</Name>
        <Script>
                        param(
[PSObject[]]
$Rows
)

$allInput = @($input)
$allRows = @($allInput) + $(if ($Rows) {
    $rows
})

$MarkdownLines = @()
$IsFirst = $true
foreach ($in in $Rows) {
    $propertyList = @(
        # we first need to get a list of properties.
        if ($in -is [Collections.IDictionary]) 
        {
            foreach ($k in $in.Keys) { # take all keys from the dictionary                
                $k
            }                        
        }
        # Otherwise, walk over all properties on the object
        else {
            foreach ($psProp in $In.psobject.properties) {                                                
                $psProp                        
            }
        }
    )

    # If we're rendering the first row of a table
    if ($IsFirst) {
        # Create the header
        $markdownLines +=
            '|' + (@(foreach ($prop in $propertyList) {
                if ($prop -is [string]) {
                    $prop
                } else {
                    $prop.Name
                }
            }) -replace ([Environment]::newline), '&lt;br/&gt;' -replace '\|', '\|' -join '|') + '|'
        # Then create the alignment row.
        $markdownLines +=
            '|' + $(
                $columnNumber =0 
                @(
                    foreach ($prop in $propertyList) {
                        $colLength = 
                            if ($prop -is [string]) {
                                $prop.Length
                            } else {
                                $prop.Name.Length
                            }
                        
                        "-" * $colLength
                        
                        
                        $columnNumber++
                    }
                ) -replace ([Environment]::newline), '&lt;br/&gt;' -replace '\|', '\|' -join '|') + '|'                    
        $IsFirst = $false
    }
    
    # Now we create the row for this object.

    $markdownLine = '|' + (
        @(
            foreach ($prop in $propertyList) {
                if ($prop -is [string]) {
                    $in.$prop
                } else {
                    $prop.Value 
                }
            }
        ) -replace ([Environment]::newline), '&lt;br/&gt;' -replace '\|', '\|' -join '|') + '|'

    $markdownLines += $markdownLine
}
$markdownLines
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>DataSet</Name>
        <GetScriptBlock>
                        return $this.'#DataSet'
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>HTML</Name>
        <GetScriptBlock>
                        if (-not $this.XML.XHTML) { return '' }
return ("$($this.XML.XHTML.InnerXML)" + [Environment]::NewLine)
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Images</Name>
        <GetScriptBlock>
                        foreach ($aNode in $this.XML | Select-Xml //img) {
    if ($aNode.Node.src) {
        $aNode.Node
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>InnerText</Name>
        <GetScriptBlock>
                        $this.XML.XHTML.InnerText
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Links</Name>
        <GetScriptBlock>
                        foreach ($aNode in $this.XML | Select-Xml //a) {
    if ($aNode.Node.href) {
        $aNode.Node
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Markdown</Name>
        <GetScriptBlock>
                        return $this.'#Markdown'
                    </GetScriptBlock>
        <SetScriptBlock>
                        param(
[PSObject[]]$Markdown
)

$currentRows = @()
$allMarkdown = @(foreach ($md in $Markdown) {    
    if ($md -isnot [string]) {        
        if ($md -is [ScriptBlock]) {
            $md = "&lt;pre&gt;&lt;code class='language-powershell'&gt;$(
                [Web.HttpUtility]::HtmlEncode(
                    "$md"
                )
            )&lt;/code&gt;&lt;pre&gt;"
        } 
        if ($md -is [Collections.IDictionary] -or 
            ($md.GetType -and -not $md.GetType().IsPrimitive))  {            
            $currentRows += $md            
            continue
        }
    }
    
    if ($currentRows) {    
        $this.ToTable($currentRows)        
        $currentRows = @()
    }

    if ($md -match '(?&gt;\.md|markdown)$' -and
        (Test-Path $md -ErrorAction Ignore)
    ) {
        $md = Get-Content -Raw $md
    }

    $yamlheader = ''
    if ($md -match '^---') {
        $null, $yamlheader, $md = $in -split '---', 3
    }

    $md
})

if ($currentRows) {    
    $allMarkdown += $this.ToTable($currentRows)
    $currentRows = @()
}

$markdown = $allMarkdown -join [Environment]::NewLine

$this | 
    Add-Member NoteProperty '#Markdown' $Markdown -Force

$this.Sync()
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Table</Name>
        <GetScriptBlock>
                        $this.XML | Select-Xml -XPath '//table' | Select-Object -ExpandProperty Node
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>XML</Name>
        <GetScriptBlock>
                        return $this.'#XMl'
                    </GetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>DefaultDisplay</Name>
        <Value>Markdown
XML</Value>
      </NoteProperty>
    </Members>
  </Type>
</Types>